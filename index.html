<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="吾本逍遥">
<meta property="og:type" content="website">
<meta property="og:title" content="微石的碎碎念">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="微石的碎碎念">
<meta property="og:description" content="吾本逍遥">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微石的碎碎念">
<meta name="twitter:description" content="吾本逍遥">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>微石的碎碎念</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">微石的碎碎念</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/正则表达式语法速查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/正则表达式语法速查/" itemprop="url">
                  正则表达式语法速查
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-10 21:49:00" itemprop="dateCreated datePublished" datetime="2018-06-10T21:49:00+08:00">2018-06-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-11 17:21:09" itemprop="dateModified" datetime="2018-06-11T17:21:09+08:00">2018-06-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/正则表达式语法速查/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/10/正则表达式语法速查/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前人总结<a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="external">揭开正则表达式的神秘面纱</a>，<a href="https://www.jb51.net/tools/zhengze.html#introduction" target="_blank" rel="external">正则表达式30分钟入门教程</a>，<a href="http://rubular.com/" target="_blank" rel="external">在线测试工具</a></p>
</blockquote>
<h1 id="某些字符"><a href="#某些字符" class="headerlink" title="某些字符"></a>某些字符</h1><table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:left">制表符</td>
</tr>
</tbody>
</table>
<h1 id="常用的元字符"><a href="#常用的元字符" class="headerlink" title="常用的元字符"></a>常用的元字符</h1><table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:left">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:left">匹配任意的空白符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:left">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:left">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">匹配字符串的开始（行的开始）</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">匹配字符串的结束（行的结束）</td>
</tr>
</tbody>
</table>
<p>如果想匹配<code>. or ^ or $</code>，需要在前面加上转义字符 <code>\</code> ，如<code>\.</code> 。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><table>
<thead>
<tr>
<th style="text-align:left">文本</th>
<th style="text-align:center">正则表达式</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">This is Jack</td>
<td style="text-align:center">\bis\b</td>
<td style="text-align:center">is</td>
</tr>
<tr>
<td style="text-align:left">This is Jack</td>
<td style="text-align:center">\sis</td>
<td style="text-align:center">is([空格]is)</td>
</tr>
<tr>
<td style="text-align:left">good good study</td>
<td style="text-align:center">^good</td>
<td style="text-align:center">good（第一个）</td>
</tr>
</tbody>
</table>
<h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><table>
<thead>
<tr>
<th style="text-align:center">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">重复<font color="red">零次</font>或更多次（贪心）</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">重复<font color="red">一次</font>或更多次 （占有）</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">重复零次或一次 （懒惰）</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:left">重复n次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:left">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:left">重复n到m次</td>
</tr>
</tbody>
</table>
<ul>
<li>贪婪(贪心) 如”*”字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，</li>
<li>懒惰(勉强) 如 “?”懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。</li>
<li>占有如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金</li>
</ul>
<h1 id="自定义指定范围"><a href="#自定义指定范围" class="headerlink" title="自定义指定范围"></a>自定义指定范围</h1><p>使用<code>[]</code>指定范围，可以匹配<code>[]</code>中任意字符。也可在<code>[]</code>中使用 <code>^</code> 符号，匹配除<code>[]</code>之外的任意字符。</p>
<p>如：</p>
<ul>
<li><code>[0-9]</code>效果与\d一致</li>
<li><code>[ijk]</code>匹配i,j,k</li>
</ul>
<h1 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h1><p>使用 <code>|</code> 字符，类似于或，如 <code>0\d{2}-\d{8}|0\d{3}-\d{7}</code>，将匹配满足 <code>0\d{2}-\d{8}</code> 或 <code>0\d{3}-\d{7}</code> 的字符，需要注意的是，匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>使用<code>()</code>进行分组，括号内的值作为子表达式，如：(1234){4}将会匹配到1234123412341234.</p>
<h1 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h1><table>
<thead>
<tr>
<th style="text-align:center">代码/语法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:left">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:left">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:left">匹配任意非数字的字符</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:left">匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td style="text-align:center">[^x]</td>
<td style="text-align:left">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">[^aeiou]</td>
<td style="text-align:left">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<h1 id="反向引用-1-2…"><a href="#反向引用-1-2…" class="headerlink" title="反向引用 \1, \2…"></a>反向引用 \1, \2…</h1><p>表达式在匹配时，表达式引擎会将小括号 “( )” 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 “<td>(.*?)</td>“。</p>
<p>\n 表示分组n，即第n个左括号(所包含的内容。</p>
<p>如：</p>
<p>源字符串：abcdaabcde</p>
<p>正则表达式：([ab])\1</p>
<p>[ab]将匹配字符a或b，当[]匹配到a时，\1==a，当[]匹配到b时，\1==b，此表达式将会匹配aa或bb。</p>
<p>也可使用<code>?&lt;name&gt;</code>给分组命名，使用<code>\k&lt;name&gt;</code>引用，<code>\b(\w+)\b\s+\1\b</code>可写成<code>\b(?&lt;name&gt;\w+)\b\s\k&lt;name&gt;\b</code>。</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(exp)</td>
<td style="text-align:center">匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>(?<name>exp)</name></td>
<td style="text-align:center">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td>(?:exp)</td>
<td style="text-align:center">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/七大查找算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/七大查找算法/" itemprop="url">
                  【转载】七大查找算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-10 20:49:00" itemprop="dateCreated datePublished" datetime="2018-06-10T20:49:00+08:00">2018-06-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-11 17:22:49" itemprop="dateModified" datetime="2018-06-11T17:22:49+08:00">2018-06-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/七大查找算法/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/10/七大查找算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转载自<a href="http://www.cnblogs.com/maybe2030/p/4715035.html#top" target="_blank" rel="external">Poll的笔记</a></p>
</blockquote>
<h1 id="查找算法简介"><a href="#查找算法简介" class="headerlink" title="查找算法简介"></a>查找算法简介</h1><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p>
<p>查找定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>查找算法分类：</p>
<ol>
<li>静态查找和动态查找。（注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。）</li>
<li>无序查找和有序查找。<ul>
<li>无序查找：被查找数列有序无序均可；</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul>
</li>
</ol>
<p>平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p>
<ul>
<li>对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。</li>
<li>Pi：查找表中第i个数据元素的概率。</li>
<li>Ci：找到第i个数据元素时已经比较过的次数。<br>回到顶部<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</li>
</ul>
<p>基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<ul>
<li>复杂度分析：<ul>
<li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</li>
<li>当查找不成功时，需要n+1次比较，时间复杂度为O(n);</li>
<li>所以，顺序查找的时间复杂度为O(n)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//顺序查找</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">        <span class="keyword">if</span>(a[i]==value)</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</p>
<p>基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p>
<p>复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；</p>
<p>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//二分查找（折半查找），版本1</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> low, high, mid;</div><div class="line">    low = <span class="number">0</span>;</div><div class="line">    high = n<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(low&lt;=high)</div><div class="line">    &#123;</div><div class="line">        mid = (low+high)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(a[mid]==value)</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</div><div class="line">            high = mid<span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</div><div class="line">            low = mid+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//二分查找，递归版本</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(a[mid]==value)</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</div><div class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</div><div class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p>
<p>打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p>
<p>同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p>
<p>经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p>
<p>mid=(low+high)/2, 即mid=low+1/2*(high-low);</p>
<p>通过类比，我们可以将查找的点改进为如下：</p>
<p>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</p>
<p>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p>
<p>基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p>
<p>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<p>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//插值查找</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</div><div class="line">    <span class="keyword">if</span>(a[mid]==value)</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</div><div class="line">        <span class="keyword">return</span> InsertionSearch(a, value, low, mid<span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</div><div class="line">        <span class="keyword">return</span> InsertionSearch(a, value, mid+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h1><p>在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p>
<p>黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p>
<p>0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p>
<p>大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p>
<p>基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p>
<p>相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p>
<ol>
<li>相等，mid位置的元素即为所求</li>
<li>>，low=mid+1;</li>
<li>&lt;，high=mid-1。</li>
</ol>
<p>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p>
<p>开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<ol>
<li>相等，mid位置的元素即为所求</li>
<li>>，low=mid+1,k-=2;<ul>
<li>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</li>
</ul>
</li>
<li>&lt;，high=mid-1,k-=1。<ul>
<li>说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。<br>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 斐波那契查找.cpp </span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></div><div class="line"></div><div class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> * F)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</div><div class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> low=<span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> high=n<span class="number">-1</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> F[max_size];</div><div class="line">  Fibonacci(F);<span class="comment">//构造一个斐波那契数组F </span></div><div class="line"></div><div class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></div><div class="line">      ++k;</div><div class="line"></div><div class="line">  <span class="keyword">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></div><div class="line">  temp=<span class="keyword">new</span> <span class="keyword">int</span> [F[k]<span class="number">-1</span>];</div><div class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</div><div class="line">     temp[i]=a[n<span class="number">-1</span>];</div><div class="line">  </div><div class="line">  <span class="keyword">while</span>(low&lt;=high)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</div><div class="line">    &#123;</div><div class="line">      high=mid<span class="number">-1</span>;</div><div class="line">      k-=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</div><div class="line">    &#123;</div><div class="line">     low=mid+<span class="number">1</span>;</div><div class="line">     k-=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">       <span class="keyword">if</span>(mid&lt;n)</div><div class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></div><div class="line">       <span class="keyword">else</span></div><div class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></div><div class="line">    &#125;</div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">delete</span> [] temp;</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</div><div class="line">    <span class="keyword">int</span> key=<span class="number">100</span>;</div><div class="line">    <span class="keyword">int</span> index=FibonacciSearch(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),key);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">" is located at:"</span>&lt;&lt;index;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h1><h2 id="最简单的树表查找算法——二叉树查找算法"><a href="#最简单的树表查找算法——二叉树查找算法" class="headerlink" title="最简单的树表查找算法——二叉树查找算法"></a>最简单的树表查找算法——二叉树查找算法</h2><p>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </p>
<p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<p>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>3）任意节点的左、右子树也分别为二叉查找树。</p>
<p>二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p>
<p>不同形态的二叉查找树如下图所示：</p>
<p><img src="http://img.my.csdn.net/uploads/201204/06/1333691114_6839.jpg" alt=""></p>
<p>有关二叉查找树的查找、插入、删除等操作的详细讲解，请移步浅谈算法和数据结构: 七 二叉查找树。</p>
<p>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p>
<p>下图为二叉树查找和顺序查找以及二分查找性能的对比图：<br><img src="https://images0.cnblogs.com/blog/94031/201403/242110240767812.png" alt=""></p>
<p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>
<h2 id="平衡查找树之2-3查找树（2-3-Tree）"><a href="#平衡查找树之2-3查找树（2-3-Tree）" class="headerlink" title="平衡查找树之2-3查找树（2-3 Tree）"></a>平衡查找树之2-3查找树（2-3 Tree）</h2><p>2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p>
<p>1）要么为空，要么：</p>
<p>2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</p>
<p>3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/252248450292152.png" alt=""></p>
<p>2-3查找树的性质：</p>
<p>1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p>
<p>2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p>
<p>性质2）如下图所示：</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/252249082017906.png" alt=""></p>
<p>复杂度分析：</p>
<p>2-3树的查找效率与树的高度是息息相关的。</p>
<ul>
<li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li>
<li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</li>
</ul>
<p>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p>
<p>对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/252249104513019.png" alt=""></p>
<p>5.3 平衡查找树之红黑树（Red-Black Tree）</p>
<p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>
<p>基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/270024368439888.png" alt=""></p>
<p>红黑树的定义：</p>
<p>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>
<ol>
<li>红色节点向左倾斜</li>
<li>一个节点不可能有两个红色链接</li>
<li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</li>
</ol>
<p>下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/270024403113529.png" alt=""></p>
<p>红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</p>
<p>复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。</p>
<p>下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/270027368747653.png" alt=""></p>
<p>红黑树的平均高度大约为logn。</p>
<p>下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，它能保证最坏情况下仍然具有对数的时间复杂度。</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/270027378905711.png" alt=""></p>
<p>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</p>
<ol>
<li>Java中的java.util.TreeMap,java.util.TreeSet；</li>
<li>C++ STL中的：map,multimap,multiset；</li>
<li>.NET中的：SortedDictionary,SortedSet 等。</li>
</ol>
<h2 id="B树和B-树（B-Tree-B-Tree）"><a href="#B树和B-树（B-Tree-B-Tree）" class="headerlink" title="B树和B+树（B Tree/B+ Tree）"></a>B树和B+树（B Tree/B+ Tree）</h2><p>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p>
<p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。</p>
<p>B树定义：</p>
<p>B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>
<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>
<p>下图是一个M=4 阶的B树:</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/290047034539184.png" alt=""></p>
<p>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入</p>
<p><code>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</code></p>
<p>的演示动画：</p>
<p><img src="https://files.cnblogs.com/files/yangecnu/btreebuild.gif" alt=""></p>
<p>B+树定义：</p>
<p>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ol>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ol>
<p>如下图，是一个B+树:</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/290050048129679.png" alt=""></p>
<p>下图是B+树的插入动画：</p>
<p><img src="https://files.cnblogs.com/files/yangecnu/Bplustreebuild.gif" alt=""></p>
<p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p>
<p>B+ 树的优点在于：</p>
<ul>
<li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>
</ul>
<p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p>
<p>下面是B 树和B+树的区别图：</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201403/290050088914733.png" alt=""></p>
<p>B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：</p>
<ul>
<li>Windows：HPFS文件系统；</li>
<li>Mac：HFS，HFS+文件系统；</li>
<li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；</li>
<li>数据库：ORACLE，MYSQL，SQLSERVER等中。</li>
</ul>
<p>有关B/B+树在数据库索引中的应用，请看张洋的MySQL索引背后的数据结构及算法原理这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</p>
<h2 id="树表查找总结："><a href="#树表查找总结：" class="headerlink" title="树表查找总结："></a>树表查找总结：</h2><p>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。</p>
<p>除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。<br>回到顶部</p>
<h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<p>算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……</p>
<p>算法流程：</p>
<ol>
<li>先选取各块中的最大关键字构成一个索引表；</li>
<li>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。<br>回到顶部<h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1></li>
</ol>
<p>什么是哈希表（Hash）？<br>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。</p>
<p>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</p>
<p>什么是哈希函数？</p>
<p>哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p>
<p>算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p>
<p>算法流程：</p>
<ol>
<li>用给定的哈希函数构造哈希表；</li>
<li>根据选择的冲突处理方法解决地址冲突；<ul>
<li>常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。</li>
</ul>
</li>
<li>在哈希表的基础上执行哈希查找。<ul>
<li>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</li>
</ul>
</li>
</ol>
<p>复杂度分析：</p>
<p>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p>
<p>使用Hash，我们付出了什么？</p>
<p>我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？</p>
<p>Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p>
<p>Hash算法和其他查找算法的性能对比：</p>
<p><img src="https://images0.cnblogs.com/blog/94031/201410/312301180197071.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/轻松搞定面试中的链表题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/轻松搞定面试中的链表题目/" itemprop="url">
                  【转载】轻松搞定面试中的链表题目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-10 19:49:00" itemprop="dateCreated datePublished" datetime="2018-06-10T19:49:00+08:00">2018-06-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-11 17:23:43" itemprop="dateModified" datetime="2018-06-11T17:23:43+08:00">2018-06-11</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/轻松搞定面试中的链表题目/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/10/轻松搞定面试中的链表题目/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转载自<a href="https://blog.csdn.net/luckyxiaoqiang/article/details/7393134" target="_blank" rel="external">计算机的艺术</a></p>
</blockquote>
<h1 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h1><p>链表是最基本的数据结构，面试官也常常用链表来考察面试者的基本能力，而且链表相关的操作相对而言比较简单，也适合考察写代码的能力。链表的操作也离不开指针，指针又很容易导致出错。综合多方面的原因，链表题目在面试中占据着很重要的地位。本文对链表相关的面试题做了较为全面的整理，希望能对找工作的同学有所帮助。</p>
<p>链表结点声明如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> m_nKey;</div><div class="line">    ListNode * m_pNext;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="求单链表中结点的个数"><a href="#求单链表中结点的个数" class="headerlink" title="求单链表中结点的个数"></a>求单链表中结点的个数</h1><p>这是最最基本的了，应该能够迅速写出正确的代码，注意检查链表是否为空。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 求单链表中结点的个数  </span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetListLength</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nLength = <span class="number">0</span>;  </div><div class="line">    ListNode * pCurrent = pHead;  </div><div class="line">    <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        nLength++;  </div><div class="line">        pCurrent = pCurrent-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> nLength;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="将单链表反转"><a href="#将单链表反转" class="headerlink" title="将单链表反转"></a>将单链表反转</h1><p>从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 反转单链表  </span></div><div class="line"><span class="function">ListNode * <span class="title">ReverseList</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">        <span class="comment">// 如果链表为空或只有一个结点，无需反转，直接返回原链表头指针  </span></div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>)    </div><div class="line">        <span class="keyword">return</span> pHead;  </div><div class="line">  </div><div class="line">    ListNode * pReversedHead = <span class="literal">NULL</span>; <span class="comment">// 反转后的新链表头指针，初始为NULL  </span></div><div class="line">    ListNode * pCurrent = pHead;  </div><div class="line">    <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        ListNode * pTemp = pCurrent;  </div><div class="line">        pCurrent = pCurrent-&gt;m_pNext;  </div><div class="line">        pTemp-&gt;m_pNext = pReversedHead; <span class="comment">// 将当前结点摘下，插入新链表的最前端  </span></div><div class="line">        pReversedHead = pTemp;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> pReversedHead;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查找单链表中的倒数第K个结点（k-gt-0）"><a href="#查找单链表中的倒数第K个结点（k-gt-0）" class="headerlink" title="查找单链表中的倒数第K个结点（k &gt; 0）"></a>查找单链表中的倒数第K个结点（k &gt; 0）</h1><p>最普遍的方法是，先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n）。代码略。</p>
<p>这里主要讲一下另一个思路，这种思路在其他题目中也会有应用。</p>
<p>主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查找单链表中倒数第K个结点  </span></div><div class="line"><span class="function">ListNode * <span class="title">RGetKthNode</span><span class="params">(ListNode * pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> <span class="comment">// 函数名前面的R代表反向  </span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(k == <span class="number">0</span> || pHead == <span class="literal">NULL</span>) <span class="comment">// 这里k的计数是从1开始的，若k为0或链表为空返回NULL  </span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    ListNode * pAhead = pHead;  </div><div class="line">    ListNode * pBehind = pHead;  </div><div class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; pAhead != <span class="literal">NULL</span>) <span class="comment">// 前面的指针先走到正向第k个结点  </span></div><div class="line">    &#123;  </div><div class="line">        pAhead = pAhead-&gt;m_pNext;  </div><div class="line">        k--;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>(k &gt; <span class="number">1</span> || pAhead == <span class="literal">NULL</span>)     <span class="comment">// 结点个数小于k，返回NULL  </span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">    <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)  <span class="comment">// 前后两个指针一起向前走，直到前面的指针指向最后一个结点  </span></div><div class="line">    &#123;  </div><div class="line">        pBehind = pBehind-&gt;m_pNext;  </div><div class="line">        pAhead = pAhead-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> pBehind;  <span class="comment">// 后面的指针所指结点就是倒数第k个结点  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="查找单链表的中间结点"><a href="#查找单链表的中间结点" class="headerlink" title="查找单链表的中间结点"></a>查找单链表的中间结点</h1><p>此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取单链表中间结点，若链表长度为n(n&gt;0)，则返回第n/2+1个结点  </span></div><div class="line"><span class="function">ListNode * <span class="title">GetMiddleNode</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>) <span class="comment">// 链表为空或只有一个结点，返回头指针  </span></div><div class="line">        <span class="keyword">return</span> pHead;  </div><div class="line">  </div><div class="line">    ListNode * pAhead = pHead;  </div><div class="line">    ListNode * pBehind = pHead;  </div><div class="line">    <span class="keyword">while</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>) <span class="comment">// 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步  </span></div><div class="line">    &#123;  </div><div class="line">        pAhead = pAhead-&gt;m_pNext;  </div><div class="line">        pBehind = pBehind-&gt;m_pNext;  </div><div class="line">        <span class="keyword">if</span>(pAhead-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">            pAhead = pAhead-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> pBehind; <span class="comment">// 后面的指针所指结点即为中间结点  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="从尾到头打印单链表"><a href="#从尾到头打印单链表" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h1><p>对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。参考代码如下：</p>
<p>自己使用栈：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从尾到头打印链表，使用栈  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode *&gt; s;  </div><div class="line">    ListNode * pNode = pHead;  </div><div class="line">    <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        s.push(pNode);  </div><div class="line">        pNode = pNode-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">while</span>(!s.empty())  </div><div class="line">    &#123;  </div><div class="line">        pNode = s.top();  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nKey);  </div><div class="line">        s.pop();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用递归函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从尾到头打印链表，使用递归  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RPrintList</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        RPrintList(pHead-&gt;m_pNext);  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nKey);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序"><a href="#已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序" class="headerlink" title="已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序"></a>已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</h1><p>这个类似归并排序。尤其注意两个链表都为空，和其中一个为空时的情况。只需要O（1）的空间。时间复杂度为O（max(len1, len2)）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 合并两个有序链表  </span></div><div class="line"><span class="function">ListNode * <span class="title">MergeSortedList</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> pHead2;  </div><div class="line">    <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> pHead1;  </div><div class="line">    ListNode * pHeadMerged = <span class="literal">NULL</span>;  </div><div class="line">    <span class="keyword">if</span>(pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey)  </div><div class="line">    &#123;  </div><div class="line">        pHeadMerged = pHead1;  </div><div class="line">        pHeadMerged-&gt;m_pNext = <span class="literal">NULL</span>;  </div><div class="line">        pHead1 = pHead1-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        pHeadMerged = pHead2;  </div><div class="line">        pHeadMerged-&gt;m_pNext = <span class="literal">NULL</span>;  </div><div class="line">        pHead2 = pHead2-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    ListNode * pTemp = pHeadMerged;  </div><div class="line">    <span class="keyword">while</span>(pHead1 != <span class="literal">NULL</span> &amp;&amp; pHead2 != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey)  </div><div class="line">        &#123;  </div><div class="line">            pTemp-&gt;m_pNext = pHead1;  </div><div class="line">            pHead1 = pHead1-&gt;m_pNext;  </div><div class="line">            pTemp = pTemp-&gt;m_pNext;  </div><div class="line">            pTemp-&gt;m_pNext = <span class="literal">NULL</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            pTemp-&gt;m_pNext = pHead2;  </div><div class="line">            pHead2 = pHead2-&gt;m_pNext;  </div><div class="line">            pTemp = pTemp-&gt;m_pNext;  </div><div class="line">            pTemp-&gt;m_pNext = <span class="literal">NULL</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>(pHead1 != <span class="literal">NULL</span>)  </div><div class="line">        pTemp-&gt;m_pNext = pHead1;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 != <span class="literal">NULL</span>)  </div><div class="line">        pTemp-&gt;m_pNext = pHead2;  </div><div class="line">    <span class="keyword">return</span> pHeadMerged;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也有如下递归解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">MergeSortedList</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> pHead2;  </div><div class="line">    <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> pHead1;  </div><div class="line">    ListNode * pHeadMerged = <span class="literal">NULL</span>;  </div><div class="line">    <span class="keyword">if</span>(pHead1-&gt;m_nKey &lt; pHead2-&gt;m_nKey)  </div><div class="line">    &#123;  </div><div class="line">        pHeadMerged = pHead1;  </div><div class="line">        pHeadMerged-&gt;m_pNext = MergeSortedList(pHead1-&gt;m_pNext, pHead2);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        pHeadMerged = pHead2;  </div><div class="line">        pHeadMerged-&gt;m_pNext = MergeSortedList(pHead1, pHead2-&gt;m_pNext);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> pHeadMerged;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="判断一个单链表中是否有环"><a href="#判断一个单链表中是否有环" class="headerlink" title="判断一个单链表中是否有环"></a>判断一个单链表中是否有环</h1><p>这里也是用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasCircle</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    ListNode * pFast = pHead; <span class="comment">// 快指针每次前进两步  </span></div><div class="line">    ListNode * pSlow = pHead; <span class="comment">// 慢指针每次前进一步  </span></div><div class="line">    <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pFast-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        pFast = pFast-&gt;m_pNext-&gt;m_pNext;  </div><div class="line">        pSlow = pSlow-&gt;m_pNext;  </div><div class="line">        <span class="keyword">if</span>(pSlow == pFast) <span class="comment">// 相遇，存在环  </span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="判断两个单链表是否相交"><a href="#判断两个单链表是否相交" class="headerlink" title="判断两个单链表是否相交"></a>判断两个单链表是否相交</h1><p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1)。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsIntersected</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)  </div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">  </div><div class="line">    ListNode * pTail1 = pHead1;  </div><div class="line">    <span class="keyword">while</span>(pTail1-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">        pTail1 = pTail1-&gt;m_pNext;  </div><div class="line">  </div><div class="line">    ListNode * pTail2 = pHead2;  </div><div class="line">    <span class="keyword">while</span>(pTail2-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">        pTail2 = pTail2-&gt;m_pNext;  </div><div class="line">    <span class="keyword">return</span> pTail1 == pTail2;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="求两个单链表相交的第一个节点"><a href="#求两个单链表相交的第一个节点" class="headerlink" title="求两个单链表相交的第一个节点"></a>求两个单链表相交的第一个节点</h1><p>对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。<br>对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。<br>两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。</p>
<p>时间复杂度，O(len1+len2)。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNode</span><span class="params">(ListNode * pHead1, ListNode * pHead2)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;  </div><div class="line">    ListNode * pTail1 = pHead1;  </div><div class="line">    <span class="keyword">while</span>(pTail1-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        pTail1 = pTail1-&gt;m_pNext;  </div><div class="line">        len1++;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;  </div><div class="line">    ListNode * pTail2 = pHead2;  </div><div class="line">    <span class="keyword">while</span>(pTail2-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        pTail2 = pTail2-&gt;m_pNext;  </div><div class="line">        len2++;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span>(pTail1 != pTail2) <span class="comment">// 不相交直接返回NULL  </span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    ListNode * pNode1 = pHead1;  </div><div class="line">    ListNode * pNode2 = pHead2;  </div><div class="line">        <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等  </span></div><div class="line">    <span class="keyword">if</span>(len1 &gt; len2)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> k = len1 - len2;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode1 = pNode1-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> k = len2 - len1;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode2 = pNode2-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">while</span>(pNode1 != pNode2)  </div><div class="line">    &#123;  </div><div class="line">        pNode1 = pNode1-&gt;m_pNext;  </div><div class="line">        pNode2 = pNode2-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">        <span class="keyword">return</span> pNode1;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="已知一个单链表中存在环，求进入环中的第一个节点"><a href="#已知一个单链表中存在环，求进入环中的第一个节点" class="headerlink" title="已知一个单链表中存在环，求进入环中的第一个节点"></a>已知一个单链表中存在环，求进入环中的第一个节点</h1><p>首先判断是否存在环，若不存在结束。在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">ListNode* <span class="title">GetFirstNodeInCircle</span><span class="params">(ListNode * pHead)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;m_pNext == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    ListNode * pFast = pHead;  </div><div class="line">    ListNode * pSlow = pHead;  </div><div class="line">    <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pFast-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        pSlow = pSlow-&gt;m_pNext;  </div><div class="line">        pFast = pFast-&gt;m_pNext-&gt;m_pNext;  </div><div class="line">        <span class="keyword">if</span>(pSlow == pFast)  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>(pFast == <span class="literal">NULL</span> || pFast-&gt;m_pNext == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 将环中的此节点作为假设的尾节点，将它变成两个单链表相交问题  </span></div><div class="line">    ListNode * pAssumedTail = pSlow;   </div><div class="line">    ListNode * pHead1 = pHead;  </div><div class="line">    ListNode * pHead2 = pAssumedTail-&gt;m_pNext;  </div><div class="line">  </div><div class="line">    ListNode * pNode1, * pNode2;  </div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;  </div><div class="line">    ListNode * pNode1 = pHead1;  </div><div class="line">    <span class="keyword">while</span>(pNode1 != pAssumedTail)  </div><div class="line">    &#123;  </div><div class="line">        pNode1 = pNode1-&gt;m_pNext;  </div><div class="line">        len1++;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;  </div><div class="line">    ListNode * pNode2 = pHead2;  </div><div class="line">    <span class="keyword">while</span>(pNode2 != pAssumedTail)  </div><div class="line">    &#123;  </div><div class="line">        pNode2 = pNode2-&gt;m_pNext;  </div><div class="line">        len2++;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    pNode1 = pHead1;  </div><div class="line">    pNode2 = pHead2;  </div><div class="line">    <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等  </span></div><div class="line">    <span class="keyword">if</span>(len1 &gt; len2)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> k = len1 - len2;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode1 = pNode1-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">int</span> k = len2 - len1;  </div><div class="line">        <span class="keyword">while</span>(k--)  </div><div class="line">            pNode2 = pNode2-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">while</span>(pNode1 != pNode2)  </div><div class="line">    &#123;  </div><div class="line">        pNode1 = pNode1-&gt;m_pNext;  </div><div class="line">        pNode2 = pNode2-&gt;m_pNext;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> pNode1;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除节点pToBeDeleted"><a href="#给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除节点pToBeDeleted" class="headerlink" title="给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted"></a>给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted</h1><p>对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(ListNode * pHead, ListNode * pToBeDeleted)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(pToBeDeleted == <span class="literal">NULL</span>)  </div><div class="line">        <span class="keyword">return</span>;  </div><div class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">NULL</span>)  </div><div class="line">    &#123;  </div><div class="line">        pToBeDeleted-&gt;m_nKey = pToBeDeleted-&gt;m_pNext-&gt;m_nKey; <span class="comment">// 将下一个节点的数据复制到本节点，然后删除下一个节点  </span></div><div class="line">        ListNode * temp = pToBeDeleted-&gt;m_pNext;  </div><div class="line">        pToBeDeleted-&gt;m_pNext = pToBeDeleted-&gt;m_pNext-&gt;m_pNext;  </div><div class="line">        <span class="keyword">delete</span> temp;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="comment">// 要删除的是最后一个节点  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(pHead == pToBeDeleted) <span class="comment">// 链表中只有一个节点的情况  </span></div><div class="line">        &#123;  </div><div class="line">            pHead = <span class="literal">NULL</span>;  </div><div class="line">            <span class="keyword">delete</span> pToBeDeleted;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            ListNode * pNode = pHead;  </div><div class="line">            <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted) <span class="comment">// 找到倒数第二个节点  </span></div><div class="line">                pNode = pNode-&gt;m_pNext;  </div><div class="line">            pNode-&gt;m_pNext = <span class="literal">NULL</span>;  </div><div class="line">            <span class="keyword">delete</span> pToBeDeleted;  </div><div class="line">        &#125;     </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/机器学习模型之支持向量机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/机器学习模型之支持向量机/" itemprop="url">
                  机器学习模型之支持向量机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-10 10:10:06 / 修改时间：11:41:21" itemprop="dateCreated datePublished" datetime="2018-06-10T10:10:06+08:00">2018-06-10</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/机器学习模型之支持向量机/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/10/机器学习模型之支持向量机/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="支持向量机基本思想"><a href="#支持向量机基本思想" class="headerlink" title="支持向量机基本思想"></a>支持向量机基本思想</h1><p>在n维空间中，可以使用n-1维超平面（可用线性方程 $\mathbf{w^Tx}+b=0$ 来描述）来分类（将n维空间分为2部分），下图以二维空间为例：</p>
<p><img src="/2018/06/10/机器学习模型之支持向量机/支持向量机.png" alt="支持向量机"></p>
<p>图中带圆圈标记的政府样本为距离超平面最近的样本点，也称支持向量。用支持向量机分类时有以下约束条件：应尽量去找正负样本正中心的超平面，这样对样本扰动容忍性好。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/10/机器学习模型之支持向量机/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/09/有限元的隐式与显式动力学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/有限元的隐式与显式动力学/" itemprop="url">
                  【转载】有限元的隐式与显式动力学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-09 10:28:48 / 修改时间：11:04:33" itemprop="dateCreated datePublished" datetime="2018-06-09T10:28:48+08:00">2018-06-09</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/09/有限元的隐式与显式动力学/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/09/有限元的隐式与显式动力学/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>本文转载自<a href="http://blog.sina.com.cn/s/blog_6465f2ed0102x32u.html" target="_blank" rel="external">长安CAE</a></p>
</blockquote>
<h1 id="动力学问题"><a href="#动力学问题" class="headerlink" title="动力学问题"></a>动力学问题</h1><p>在讨论隐式与显式动力学之前，先讨论一下动力学问题和静力学问题。在求解静力学问题时没有时间的概念，即使在载荷步控制力有Time这个选项，但是这个Time的含义更多的是载荷步。Time前后的求解过程相互没有影响。</p>
<p>动力学问题的特点是施加到结构上的外载荷的大小和方向可能随着时间的变化而发生变化，使结构产生速度和加速度。在用有限元求解静力学问题时主要是求矩阵方程组的问题，如下所示，只需要考虑结构的刚度矩阵。</p>
<p><img src="http://s5.sinaimg.cn/mw690/001PZA97zy716Vq4Ysc24&amp;690" alt="有限元的隐式与显式动力学"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/09/有限元的隐式与显式动力学/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/常用排序算法的代码实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/常用排序算法的代码实现/" itemprop="url">
                  常用排序算法代码实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-05 18:00:00 / 修改时间：18:02:16" itemprop="dateCreated datePublished" datetime="2018-06-05T18:00:00+08:00">2018-06-05</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/05/常用排序算法的代码实现/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/05/常用排序算法的代码实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>本文使用python代码实现了常用的排序算法，并分析复杂度。有关动图以及算法详细介绍可以参考<a href="http://www.cnblogs.com/eniac12/p/5329396.html#s6" target="_blank" rel="external">blog</a></p>
</blockquote>
<h1 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h1><ul>
<li><p>基本介绍</p>
<p>  插入排序法依次选择元素，当选择第i位元素时，<code>[0,i]</code>为已排序序列，比较第i+1位元素大小并将其插入<code>[0,i+1]</code>序列中合适的位置。</p>
</li>
<li><p>算法复杂度</p>
<p>  插入排序法分为比较与插入（交换）2个过程。</p>
<ol>
<li>最好情况：$O(n)$</li>
<li>最坏情况：$O(N^2)$</li>
<li>平均情况：$O(N^2)$</li>
<li>稳定<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(l)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(l)):</div><div class="line">        num=l[i]</div><div class="line">        j=i</div><div class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>):</div><div class="line">            <span class="keyword">if</span>(l[j]&lt;l[j<span class="number">-1</span>]):</div><div class="line">                l[j],l[j<span class="number">-1</span>]=l[j<span class="number">-1</span>],l[j]</div><div class="line">                j-=<span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">l=[<span class="number">0</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">65</span>]</div><div class="line">Insert(l)</div><div class="line">print(l)</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/05/常用排序算法的代码实现/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/机器学习之集成学习小计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/机器学习之集成学习小计/" itemprop="url">
                  集成学习小计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-04 23:49:00" itemprop="dateCreated datePublished" datetime="2018-06-04T23:49:00+08:00">2018-06-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-10 11:42:00" itemprop="dateModified" datetime="2018-06-10T11:42:00+08:00">2018-06-10</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/04/机器学习之集成学习小计/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/04/机器学习之集成学习小计/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>本文为阅读西瓜书的总结笔记。部分参考<a href="http://izhaoyi.top/2017/07/03/ensemble/" target="_blank" rel="external">懒死骆驼</a></p>
</blockquote>
<h1 id="何为集成学习"><a href="#何为集成学习" class="headerlink" title="何为集成学习"></a>何为集成学习</h1><p>集成学习通过构建并结合多个学习器来完成学习任务。先训练一组个体学习器，再通过策略将其结合起来。</p>
<h2 id="集成学习的关键"><a href="#集成学习的关键" class="headerlink" title="集成学习的关键"></a>集成学习的关键</h2><p>如何使多个学习器的结合比单一学习器性能优越？关键在于学习器的<strong>多样性与准确性</strong>。</p>
<p>即个体学习器需要有一定的准确性，不能太坏，同时又需要有多样性，个体之间要有差异。但多样性与准确性往往相互冲突。</p>
<p>如何产生并结合好而不同的个体学习器是集成学习的<strong>核心</strong>。</p>
<h2 id="集成学习的分类"><a href="#集成学习的分类" class="headerlink" title="集成学习的分类"></a>集成学习的分类</h2><p>目前集成学习主要可分为2大类，即：</p>
<ol>
<li>boosting：弱学习器之间存在强依赖关系，必须串行生成的序列化方法。</li>
<li>bagging：弱学习器之间不存在强依赖关系，可以并行生成。</li>
</ol>
<p>bagging和boosting分别是关注降低方差和降低偏差的两个代表，GDBT的每棵树生成都要比上棵树偏差小。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/04/机器学习之集成学习小计/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/OJ读取输入样例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/OJ读取输入样例/" itemprop="url">
                  OJ读取输入样例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-04 21:49:00 / 修改时间：23:54:11" itemprop="dateCreated datePublished" datetime="2018-06-04T21:49:00+08:00">2018-06-04</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/04/OJ读取输入样例/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/04/OJ读取输入样例/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>在OJ、牛客网上，经常有在线编程题需要读取输入样例,另外可能还需要一定的格式化输出知识，之前一直不太会这方面，此处来汇总一下。</p>
</blockquote>
<h1 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h1><p>python的比较简单，可以直接通过<code>input()</code>语句读取一整行内容，并返回str类型。具体使用如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = input(<span class="string">"input:"</span>)</div><div class="line">input:<span class="number">123</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="string">'123'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></div><div class="line">&gt;&gt;&gt; a = int(input("input:"))</div><div class="line">input:<span class="number">123</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line"><span class="number">123</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></div></pre></td></tr></table></figure></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/06/04/OJ读取输入样例/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/nowcoder错题查缺补漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/nowcoder错题查缺补漏/" itemprop="url">
                  nowcoder错题查缺补漏
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-04 09:49:00" itemprop="dateCreated datePublished" datetime="2018-06-04T09:49:00+08:00">2018-06-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-05 19:48:54" itemprop="dateModified" datetime="2018-06-05T19:48:54+08:00">2018-06-05</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/04/nowcoder错题查缺补漏/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/06/04/nowcoder错题查缺补漏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>此博客用来总结牛客网刷题过程中一些错题，特别是一些自己没有搞懂的、模糊的知识点。会尽量按照知识点来分类。</p>
</blockquote>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下程序输出是____。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span> *)(&amp;a);</div><div class="line">    *p = <span class="number">20</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="string">", *p = "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//答案：a = 10, *p = 20</span></div></pre></td></tr></table></figure>
<p>在C++中，a作用域下在C++中所有的常量a在预编译阶段就已经做了类似于宏替换的工作，所以输出的是它的常量值，尽管a所对应的内存地址上的值已经发生改变，但还是输出常量值。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/机器学习模型之BP神经网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="微石">
      <meta itemprop="description" content="吾本逍遥">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="微石的碎碎念">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/机器学习模型之BP神经网络/" itemprop="url">
                  BP神经网络小节
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-31 15:10:06" itemprop="dateCreated datePublished" datetime="2018-05-31T15:10:06+08:00">2018-05-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-04 23:48:32" itemprop="dateModified" datetime="2018-06-04T23:48:32+08:00">2018-06-04</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/31/机器学习模型之BP神经网络/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2018/05/31/机器学习模型之BP神经网络/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="训练神经网络的步骤"><a href="#训练神经网络的步骤" class="headerlink" title="训练神经网络的步骤"></a>训练神经网络的步骤</h1><p>训练神经网络：</p>
<ol>
<li>参数的随机初始化</li>
<li>利用正向传播方法计算所有的$h_{\theta}(y)$</li>
<li>编写计算代价函数 $J$ 的代码</li>
<li>利用反向传播方法计算所有偏导数</li>
<li>利用数值检验方法检验这些偏导数</li>
<li>使用优化算法来最小化代价函数</li>
</ol>
<p>简单来说即是：正向传播信号，反向传播误差。通过正向传播方法，我们从第一层开始正向一层一层进行计算，直到最后一层的$h_{\theta}(y)$。现在，为了计算代价函数的偏导数$\frac{\partial}{\partial\Theta^{(l)}_{ij}}J\left(\Theta\right)$，我们需要采用一种反向传播算法，也就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，直到倒数第二层。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/05/31/机器学习模型之BP神经网络/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="微石" />
            
              <p class="site-author-name" itemprop="name">微石</p>
              <p class="site-description motion-element" itemprop="description">吾本逍遥</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/akihoo/" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xfyuu1@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">微石</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.3.9</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


















  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.2.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'j0BO2jEqJeAlI7OmNgO3u6c8-gzGzoHsz',
        appKey: 'G3iYBi1UqmHMjy8QxLeFaRpB',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

</body>
</html>
